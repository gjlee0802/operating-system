# 면접 기출 예시

## 개념 질문

### 1. Process와 Thread의 주요 차이를 설명하시오. (중요!)
| 항목             | **Process**                                      | **Thread**                                                        |
|------------------|--------------------------------------------------|-------------------------------------------------------------------|
| **정의**          | 실행 중인 프로그램의 인스턴스                        | 프로세스 내에서 실행되는 **가벼운 실행 단위**                            |
| **자원(메모리) 공간** | 독립된 메모리 공간 사용 (Heap, Stack, Code 등)       | **프로세스와 메모리 공유** (Heap, Code 공유 / Stack은 개별)         |
| **오버헤드**       | 생성/전환 비용 큼                                  | 비용 작고 빠름                                                    |
| **통신 방법**      | 프로세스 간 통신(IPC) 필요 (복잡함)                  | 공유 메모리 사용 (간단하고 빠름)                                   |
| **독립성**        | 완전히 독립적                                       | 같은 프로세스 내 다른 쓰레드와 연결되어 있음                          |
| **예외 처리**      | 하나의 프로세스가 종료돼도 다른 프로세스는 영향 없음      | 한 쓰레드의 오류가 전체 프로세스에 영향을 줄 수 있음                  |


**메모리 구조의 차이** (`Code, Data, Heap, Stack` 영역):  
~~~
프로세스는 자신만의 독립된 메모리 공간을 가져 완전히 분리되어 있음
쓰레드는 Code, Data, Heap 영역을 공유하며, Stack은 쓰레드마다 개별적으로 따로 존재
~~~

### 2. Thread를 사용하는 것이 Process보다 가지는 장점 중 하나를 제시하시오. (P 24-25 First)
~~~
🎯 스레드는 같은 프로세스 내에서 메모리 공간(코드, 데이터, 파일 등)을 공유하기 때문에,
스레드 간 통신이 매우 빠르고 효율적임

→ 예를 들어, 스레드끼리는 별도의 IPC(프로세스 간 통신) 없이 공유 변수를 통해 데이터를 주고받을 수 있음
~~~

### 3. Process를 사용하는 것이 Thread보다 가지는 장점 중 하나를 제시하시오. (P 24-25 First)
~~~
🎯 프로세스는 서로 독립된 메모리 공간을 사용하기 때문에,
하나의 프로세스에 문제가 생겨도 다른 프로세스에 영향을 주지 않음

→ 즉, 안정성과 오류 격리 측면에서 유리합니다.
~~~

## 💪 심층 문제

### 1. 프로세스가 fork() 를 사용하여 새로운 프로세스를 생성할 때, 다음 중 부모 프로세스와 자식 프로세스 사이에 공유되는 상태는 무엇인가? 단, CoW는 적용되지 않는다고 가정한다. (P 22-23 First)
~~~
(a) Stack
(b) Heap
(c) Shared memory segments
(d) Registers
~~~

**영역별 설명 표**:
| 메모리 영역          | 부모-자식 간 공유 여부 | 설명                             |
|----------------------|------------------------|----------------------------------|
| **Stack** (a)        | ❌ 복사됨 (독립적)     | 함수 호출, 지역 변수 저장          |
| **Heap** (b)         | ❌ 복사됨 (독립적)     | 동적 메모리 (`malloc`, `new` 등)   |
| **Data**             | ❌ 복사됨 (독립적)     | 전역 변수, static 변수             |
| **Code/Text**        | ❌ 복사됨 (독립적)     | 실행 코드.                         |
| **Shared Memory**(c) | ✅ 공유됨              | `shmget`, `mmap` 등을 통해 명시적으로 공유 |
| **Registers**(d)     | ❌ 복사됨              | 레지스터 상태도 복사되지만 서로 영향 없음 |

**fork() 후의 메모리 레이아웃 개요**:  
~~~
┌───────────────────────┐      ┌───────────────────────┐
│     Parent Process    │      │     Child Process     │
├───────────────────────┤      ├───────────────────────┤
│      Stack (복사됨)    |      │      Stack (복사됨)   │
├───────────────────────┤      ├───────────────────────┤
│      Heap (복사됨)     │      │      Heap (복사됨)    │
├───────────────────────┤      ├───────────────────────┤
│      Data (복사됨)     │      │      Data (복사됨)    │
├───────────────────────┤      ├───────────────────────┤
│      Code/Text        │      │      Code/Text        │
│  (보통 공유, 읽기 전용) │      │  (보통 공유, 읽기 전용)│
├───────────────────────┤      ├───────────────────────┤
│  Shared Memory Segment│◄─────┤  Shared Memory Segment│
│    (IPC용, 공유됨)     │─────►│    (IPC용, 공유됨)     │
└───────────────────────┘      └───────────────────────┘
~~~

✅ **참고, Copy-on-Write** (**COW**):  
현대 OS에서는 **Heap, Stack, Data를 실제로 복사하지 않고**,  
"Copy-on-Write (CoW)" 방식(**쓰기 시점에 복사**)으로 성능을 최적화함.  
* 읽기만 할 땐 부모와 자식이 같은 메모리 참조
* **쓰기 시점에만 실제 메모리 분리**

-----

### 2. A context switching may occur between threads or between processes. In the following table, indicate whether each action occurs or not upon switching between threads and switching between processes, respectively. Mark O to indicate an action occurs; mark X to indicate an action does not occur. (P 22-23 Second)

| Action                | Switching threads | Switching process | 설명 |
|-----------------------|-------------------|-------------------|------|
| **Switching registers**    | O | O | CPU의 일반 레지스터는 어떤 실행 단위든 저장/복원해야 하므로 O |
| **Switching PC (Program Counter)** | O | O | 다음에 실행할 명령어 주소도 항상 전환 시 저장/복원해야 하므로 O |
| **Switching Stack Pointer** | O | O | 각 쓰레드/프로세스마다 스택이 따로 존재하므로 당연히 O |
| **Switching Page Table** | X | O | 쓰레드는 프로세스의 주소 공간을 공유하므로 X, 프로세스는 분리된 주소 공간을 가지므로 O |
| **Saving/Restoring PCB** | X | O | PCB(Process Control Block)는 프로세스 단위 정보이므로, **쓰레드 전환에서는 필요 없음** |
